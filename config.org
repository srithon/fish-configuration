#+title: Fish Configuration
#+PROPERTY: :header-args:fish: :noweb yes

* Preprocessor Constants
#+NAME: CONFIG_ROOT
#+begin_src fish
/home/sridaran/.config/fish
#+end_src
* Startup Code
:PROPERTIES:
:header-args:fish: :tangle ./config.fish :noweb yes
:END:
First and foremost, let's source our environment file.
#+begin_src fish
source <<CONFIG_ROOT>>/env.fish
#+end_src

** Initializing Plugins
Initialize ~opam~.
#+begin_src fish
source /home/sridaran/.opam/opam-init/init.fish > /dev/null 2> /dev/null; or true
#+end_src

Initialize ~starship~ and ~zoxide~.
#+begin_src fish
starship init fish | source
zoxide init fish | source
#+end_src
** Set Vi Bindings
#+begin_src fish
function my_vi_bindings
  fish_vi_key_bindings
  bind -M insert -m default jk backward-char force-repaint
end

set -g fish_key_bindings my_vi_bindings
#+end_src
*** Override Mode Cursors
The default cursors made me uncomfortable, mainly the blinking line cursor in insert mode.
#+begin_src fish
set fish_cursor_visual block
set fish_cursor_normal block blink
set fish_cursor_unknown block blink
set fish_cursor_insert block
set fish_cursor_replace_one underscore
#+end_src
** Sourcing External Files
Let's source our alias files.
#+begin_src fish
source <<CONFIG_ROOT>>/pure-aliases.fish
source <<CONFIG_ROOT>>/impure-aliases.fish
#+end_src

Let's source all ~fish~ files under our ~custom-functions~ directory, for things that are not tracked under our Literate configuration.

#+begin_src fish
for file in <<CONFIG_ROOT>>/custom-functions/**.fish
    source "$file"
end
#+end_src
** Set Fzf Keybindings
#+begin_src fish
fzf_configure_bindings
#+end_src
* Functions
:PROPERTIES:
:header-args:fish: :tangle (srithon/compute-fish-config-tangle-file)
:END:
** Set Fish Greeting
#+begin_src fish
function fish_greeting
end
#+end_src
** Pure Aliases
:PROPERTIES:
:header-args:fish: :tangle ./pure-aliases.fish
:END:

=Pure= aliases do not depend on any other functions/aliases in my configuration.
They go on the top so that the rest of the config can use them.
*** ~ls~
#+begin_src fish
alias ls="exa"
alias l="ls -l"
alias la="l -a"
#+end_src
*** ~nvim~
#+begin_src fish
alias v="nvim"
alias v4="/home/sridaran/Packages/neovim/nvim0-4-4.appimage"
alias v5="nvim"

# runs with no history
alias incv="v -i NONE"
#+end_src
*** ~grep~
#+begin_src fish
alias grep="rg"
#+end_src
*** ~docker~
I use ~podman~ instead of ~docker~, but typing ~docker~ is nicer for muscle memory.
#+begin_src fish
alias docker="podman"
#+end_src
*** ~zfs~
This is a simple alias for listing out the snapshots on the current system.
Because it's an alias, you can specify a dataset afterwards to get the snapshots for the given dataset.
Also, ~fish~ uses the completions from the underlying command, so it will autocomplete the datasets!
#+begin_src fish
alias snapshots="zfs list -t snapshot"
#+end_src
*** ~termshot~
For some reason I don't trust this program, so I setup this alias to always run it in ~firejail~.
#+begin_src fish
alias termshot='firejail --quiet termshot'
#+end_src
*** ~shutdown~
I have ~shutdown~ aliased to first prompt to send my snapshots to my backup server before shutting down.
*NOTE*: with the current ~argparse~ implementation, we can't do things like ~shutdown -nc~ and expect it to work normally; this is because ~argparse~ doesn't allow us to mix foreign and accepted options in a single dash group when we have the ~--ignore-unknown~ flag enabled.
In the future, we should refactor this function so that it doesn't use ~argparse~.
#+begin_src fish
function zfs_sync_and_shutdown -d "Prompts for ZFS sync and then shuts down"
    argparse --ignore-unknown 'h/help' 'n/no-sync' -- $argv

    set continue_shutdown 1
    # NOTE: argparse transliterates dashes to underscores
    if not set -q _flag_no_sync
        and not sudo ~/Development/General/kalavara/send_snapshots.sh
        set continue_shutdown 0
    end

    if test $continue_shutdown -eq 1
        # now, if the last argument in $argv starts with a dash, then infer that
        # there is no time specification and that we should instead shutdown `now`
        set shutdown_time
        if not test (count $argv) -gt 0
            # treat the last thing in $argv as the time spec;
            # NOTE: we have to use -- so that the string doesn't get treated as
            # an option for string match
            or string match --regex '^-' -- $argv[-1] > /dev/null
            set shutdown_time 'now'
        end

        /sbin/shutdown $argv $shutdown_time
    end
end

alias shutdown="zfs_sync_and_shutdown"
#+end_src
*** ~encvi~
This is an abbreviation that simply calls ~[SPC]sudo encvi~.
Unfortunately, Fish does not provide ~$HISTIGNORE~ functionality, whereby one can exclude certain commands from showing up in the history.
Therefore, we have to resort to expanding ~encvi~ to prefix itself with a space so that it will not be recorded.
#+begin_src fish
abbr --add encvi ' sudo encvi'
#+end_src
*** ~cpufreq~
This is an alias for ~set_cpufreq_profile~, a script that I wrote for creating a ~rofi~ popup window allowing me to choose between CPU profiles.
#+begin_src fish
alias cpufreq=set_cpufreq_profile
#+end_src
*** ~systemctl~
~systemctl~ can be annoying to type, so we'll make abbreviations for the common stems: ~systemctl~ and ~systemctl --user~.
Let's write a function which will allow us to make root-level and user-level abbreviation variants for different ~systemctl~ subcommands.
#+begin_src fish
function __make_systemctl_abbrs -d "Makes sys and sysu abbreviations with the given suffixes" -a abbr_suffix_char command_suffix
    abbr --add "sys$abbr_suffix_char" (string trim "systemctl $command_suffix")
    abbr --add "sysu$abbr_suffix_char" (string trim "systemctl --user $command_suffix")
end
#+end_src

First, we'll make the bare abbreviations ~sys~ and ~sysu~, without any subcommands.
#+begin_src fish
__make_systemctl_abbrs "" ""
#+end_src

Now, let's define abbreviations for the common subcommands, like ~sysu+~ for ~systemctl --user start~.
#+begin_src fish
__make_systemctl_abbrs "+" "start"
__make_systemctl_abbrs "-" "stop"
__make_systemctl_abbrs "?" "status"
__make_systemctl_abbrs "*" "restart"
#+end_src
** System Introspection
These functions yield information about the system from the terminal.
*** ~memof~
#+begin_src fish
function memof -a PROGRAM_NAME -d "Sums the memory usage of all matching processes"
    procs $PROGRAM_NAME 2>/dev/null | tail -n "+3" | awk '{sum += $5} END { print sum }'
end
#+end_src
*** ~get_volume~
#+begin_src fish
function get_volume
    amixer -M get Master | rg -m1 '\[(\d+)%\]' --only-matching -r '$1'
end
#+end_src
*** ~battery~
#+begin_src fish
function battery -d "Displays the current battery status"
    set -l charge (cat /sys/class/power_supply/BAT0/capacity)
    # $status is a protected Fish variable
    set -l bat_status (cat /sys/class/power_supply/BAT0/status)
    set -l capacity_level (cat /sys/class/power_supply/BAT0/capacity_level)
    echo "$charge"% "[$capacity_level]" "[$bat_status]"
end
#+end_src
** Desktop Application Launcher
*** Emacs
Let's write a helper function for invoking emacs so that we don't have to worry about the idiosyncracies of the ~emacsclient~ CLI.
#+begin_src fish
function _open_emacs -a OPEN_GUI -a MAKE_NEW_FRAME
    # because this is a FUNCTION and not a BINARY, $argv will not contain the name of the function
    # NOTE $OPEN_GUI and $MAKE_NEW_FRAME are counted inside of $argv, so we have to increment by 1
    if [ (count $argv) -eq 2 ]
        set FILES "."
    else
        set FILES $argv[3..]
    end

    # couldn't figure out how to get --create-frame and $FILES to be interpreted as 2 separate arguments
    # they needed to be concatenated without a space between the variables
    if [ "$OPEN_GUI" -eq 1 ]
        set -f ARGS --no-wait

        if [ "$MAKE_NEW_FRAME" -eq 1 ]
            set -a ARGS --create-frame
        end

        emacsclient $ARGS $FILES
    else
        emacsclient $FILES
    end
end
#+end_src

Our core function will be ~open_emacs_gui~, which will enable us to choose whether we want to open our file in an existing ~emacs~ window, or whether we want a new one to be created.
#+begin_src fish
function open_emacs_gui
    argparse --ignore-unknown --stop-nonopt --name=open_emacs_gui 'h/help' 'e/existing' -- $argv

    if set -q _flag_help
        echo "Usage: $0 [-e/--existing] [files...]" > /dev/stderr
        return 1
    end

    set -q _flag_existing; and set MAKE_NEW_FRAME 0; or set MAKE_NEW_FRAME 1

    fish -c "_open_emacs 1 $MAKE_NEW_FRAME $argv"
end
#+end_src

To make things easier to call, we will alias ~e~ to ~open_emacs_gui~, since we will be using that one the most often, and ~et~ to opening ~emacs~ in the terminal.
#+begin_src fish
# open in gui
alias e="open_emacs_gui"

# open in terminal
alias et="_open_emacs 0 0"
#+end_src
*** Dolphin
This is a simple function for opening ~dolphin~, defaulting to the current directory.
By default, running the ~dolphin~ binary without arguments will open it in the home directory, which is rarely what we want.
#+begin_src fish
function _open_dolphin --wraps dolphin
    if [ (count $argv) -eq 0 ]
        spawn dolphin .
    else
        spawn dolphin $argv
    end
end
#+end_src

Let's set the ~d~ alias to make it more convenient to use it.
#+begin_src fish
alias d="_open_dolphin"
#+end_src
*** Krita
Here, we define ~newkrita~, which is a function that clones a default canvas template, saves it to the target path, and opens ~krita~ on that file.
Admittedly, I don't remember why, but this is more convenient than trying to open a non-existent file in Krita.
#+begin_src fish
# NOTE we were getting an error because the argument to newkrita was named "PATH"
# this "PATH" was overriding the PATH variable
function newkrita -a TARGET_PATH
  /home/sridaran/Development/Scripts/fish/krita/new_krita.fish "$TARGET_PATH"
  spawn krita "$TARGET_PATH"
end
#+end_src
*** Remmina
:PROPERTIES:
:function-name: remote-desktop
:END:
When opening Remmina, I often just want to open a single RDP connection, and after opening the connection I end up closing the main window.
To make this workflow more convenient, let's make a function which will allow us to directly open an RDP connection from the terminal without going into the GUI.
#+begin_src fish
set REMMINA_PROFILE_DIR ~/.local/share/remmina
#+end_src

#+begin_src fish
function remote-desktop -a PROFILE -d "Opens a remote-desktop session using the provided Remmina profile"
    spawn remmina -c $REMMINA_PROFILE_DIR/$PROFILE
end
#+end_src

Let's add tab completion using the profiles
#+begin_src fish
function __remote-desktop-completion -d "Yields (file, description) pairs for `remote-desktop` function"
    set PROFILES (fd . $REMMINA_PROFILE_DIR -tfile)
    set PROFILE_NAMES (rg --no-filename --only-matching --replace '$1' '^name=(.+)' $PROFILES)

    for i in (seq 1 (count $PROFILES))
        echo -e "$(basename $PROFILES[$i])\t$PROFILE_NAMES[$i]"
    end
end

complete --no-files --command remote-desktop -a "(__remote-desktop-completion)"
#+end_src
** Desktop Utilities
*** PDF Utilities
This function converts a PDF to a vertical image, which all of the pages stacked.
#+begin_src fish
function pdftoimagevertical -a PDF_FILE -a IMAGE_NAME -d "Converts a pdf to a single image"
    set -l temp_root (mktemp -d)
    set -l pdf_name (basename "$PDF_FILE")
    set -l ppm_root "$temp_root/$PDF_FILE"

    pdftoppm "$PDF_FILE" "$ppm_root"
    convert "$temp_root"/* -append "$IMAGE_NAME"

    rm "$temp_root"/*
    rmdir "$temp_root"
end
#+end_src
*** XWindows Utilities
**** ~xdotool~ helpers
This alias enables you to programmatically type a string, with a builtin delay to leave the terminal.
#+begin_src fish
alias xtype="sleep 2; xdotool type -- "
#+end_src
**** Clipboard functions
This is a function which allows us to display clipboard contents, as well as easily pipe into the clipboard.
#+begin_src fish
function clipboard
    if isatty stdin
        # if stdin is not connected to a PIPE, output current clipboard
        xsel --clipboard
    else
        # if stdin IS connected to a pipe, read input into clipboard
        xclip -selection c -r
    end
end
#+end_src

The ~copy~ alias allows you to pipe the results of a command into the clipboard, while also displaying the output to ~stdout~.
#+begin_src fish
alias copy='tee /dev/tty | clipboard'
#+end_src
***** Un-googling Clipboard
I wrote an ~ungoogle~ script for taking a Google link and extracting the original URL.
A common operation for me is ungoogling and writing back the contents of the clipboard, so let's make an alias for that.
We ~copy~ at the end so that the result is also displayed to ~stdout~.
#+begin_src fish
alias ungoogle-clipboard='clipboard | ungoogle | copy'
#+end_src
***** Ascii-fying Clipboard
I often want to convert the clipboard text into ASCII, so let's make an alias for that too.
#+begin_src fish
alias asciify-clipboard='clipboard | to-ascii | copy'
#+end_src
*** KDE Utilities
This function enables/disables the touchpad.
#+begin_src fish
function touchpad_toggle
    # https://www.reddit.com/r/kde/comments/dnx4dh/disable_touchpad_when_mouse_is_connected/?sort=top
    qdbus org.kde.kded5 /modules/touchpad org.kde.touchpad.toggle
end
#+end_src
*** TODO Change Audio
#+begin_src fish
function change-audio -d "Prompts for a change in audio output + volume"
    # features:
    # 1. name
    # 2. volume->front-left->value_percent: "10%"
    # 3. ports
    #   - (name, description); probably use description for display
    # 4. active_port
    set -l filtered_data (pactl -f json list sinks | jq "select(map(.name == \"$default_sink\")) | first | {volume: .volume.\"front-left\".value_percent, ports: (.ports | map({name, description})), active_port}")

    set -l volume (echo "$filtered_data" | jq '.volume')
    set -l ports (echo "$filtered_data" | jq '.ports | map("\(.name):\(.description)") | join("\n")')
    set -l active_port (echo "$filtered_data" | jq '.active_port')
end
#+end_src
*** Recording Videos
#+begin_src fish
function record -a TARGET -d "Convenience function for using simplescreenrecorder and moving the resulting recording to a target file"
  simplescreenrecorder > /dev/null 2> /dev/null

  if test -z "$TARGET"
    set -l DATE (date "+%F_%T")
    set -l TARGET "$DATE"
  end

  set -l TARGET "$TARGET.mkv"

  mv /home/sridaran/Videos/simplescreenrecorder.mkv "$TARGET"
end
#+end_src
** Convenience Functions
*** Math Functions
These are pretty much never useful but I keep them around for fun.
#+begin_src fish
function hypotenuse
    qalc "sqrt(($argv[1])^2 + ($argv[2]^2))"
end
#+end_src

#+begin_src fish
function simplify
  qalc $argv[1..-1] | awk -F "=|â‰ˆ" '{print $(NF-1)}' | string trim
end
#+end_src

#+begin_src fish
alias integrate='qalc -c integrate'
alias derivative='qalc -c derivative'
#+end_src
*** Static Shortcuts
:PROPERTIES:
:ID:       a740b499-13b5-4988-ab9c-8e47ce9ff69d
:END:
**** ~schedule~
~schedule~ opens my college schedule in an image viewer.
#+begin_src fish
function schedule
    spawn feh "$CURRENT_GRADE/../currentSchedule.png"
end
#+end_src
**** ~address~
~address~ prints out my apartment's address to ~stdout~.
#+begin_src fish
function address
    cat "$CURRENT_GRADE/../address"
end
#+end_src
**** ~resume~
~resume~ displays my latest resume in a PDF viewer.
#+begin_src fish
function resume
    set path ~/Documents/Resumes/CMSC-2022/exports/SridaranThoniyil.pdf
    if status is-command-substitution
        echo $path
    else
        spawn okular $path
    end
end
#+end_src
**** ~transcript~
~transcript~ displays my latest unofficial transcript.
#+begin_src fish
function transcript
    set path ~/Documents/school/college2/general/transcripts/07-06-23_unofficial.pdf
    if status is-command-substitution
        echo $path
    else
        spawn okular $path
    end
end
#+end_src
**** ~blackscreen~
~blackscreen~ launches a ~feh~ image viewer to black out a screen.
#+begin_src fish
alias blackscreen='feh --hide-pointer --class blackscreen --auto-zoom ~/Documents/General/blackImage.png'
#+end_src
**** ~upip~
A recent update in Arch Linux resulted in ~pip install --user~ no longer being allowed by default.
This is because the user-local packages would override the system packages and cause weird issues.
The recommended fix is to always install packages in a virtual environment, and to make that easier we'll make a shortcut for invoking the Virtual Environment's ~pip~.
#+begin_src fish
alias upip=~/.pip-venv/bin/pip
#+end_src
**** ~upython~
Let's also make an alias for the VEnv's ~python~ install.
#+begin_src fish
alias upython=~/.pip-venv/bin/python
#+end_src
*** Shell Shortcuts
**** ~spawn~
~spawn~ is an extraordinary useful function for running a command and detaching it from the terminal.
#+begin_src fish
function spawn
    disown ($argv[1..-1] </dev/null &>/dev/null &)
end
#+end_src

Because I use it so often, it's useful to have an auto-expanding abbreviation for it.
#+begin_src fish
abbr --add s spawn
#+end_src
**** ~mkdirc~
#+begin_src fish
function mkdirc -d "Makes a directory and cds into it at the same time" -a DIRECTORY
    mkdir -p "$DIRECTORY" && cd "$DIRECTORY"
end
#+end_src
**** ~jrunc~
#+begin_src fish
function jrunc
  jrun -c $argv
end
#+end_src
**** ~jrun~
#+begin_src fish
function jrun
  argparse 'a/asserts' 'c/compile' -- $argv

  set JAVA_COMMAND "java"
  if not test -z "$_flag_asserts"
    set -a JAVA_COMMAND "-ea"
  end

  set -a JAVA_COMMAND (echo "$argv[1]" | cut -d "." -f 1) $argv[2..-1]

  if not test -z "$_flag_compile"
    javac "$argv[1]" || return 1
  end

  $JAVA_COMMAND
end
#+end_src
**** ~to-ascii~
This is a little snippet for converting Unicode text into ASCII.
Source for ~$command~: [[https://stackoverflow.com/questions/1975057/bash-convert-non-ascii-characters-to-ascii][Bash: Convert non-ASCII characters to ASCII - Stack Overflow]].
#+begin_src fish
function to-ascii -d "Given text through STDIN or as a command-line argument, converts non-ASCII characters to ASCII"
    set command iconv -f UTF8 -t US-ASCII//TRANSLIT

    # if being piped into, then STDIN is not a tty
    if ! isatty stdin
        # the command will take in the text on STDIN
        $command
    else
        if [ (count $argv) -ge 1 ]
            # output each argument on a separate line
            string join \n $argv | $command
        else
            echo "If you are not piping in text, please specify it as a string on the command line!" > /dev/stderr
            return 1
        end
    end
end
#+end_src
**** ~format-seconds~
#+begin_src fish
function format-seconds -d "Given a certain number of seconds, formats it into larger time units" -a SECONDS
  set -l SECONDS_REAL (math $SECONDS % 60)

  set -l MINUTES_TOTAL (math "$SECONDS / 60")
  set -l MINUTES_REAL (math "floor($SECONDS / 60) % 60")

  set -l HOURS_TOTAL (math "$MINUTES_TOTAL / 60")
  set -l HOURS_REAL (math "floor($MINUTES_TOTAL / 60) % 60")

  set -l DAYS_REAL (math "floor($HOURS_TOTAL / 24) % 24")

  set -l return_list
  for unit in days hours minutes seconds
      set -l varname "$(echo $unit | string upper)_REAL"

      if test $$varname -ne 0
          set -a return_list "$$varname $unit"
      end
  end

  echo (string join ', ' $return_list)
end
#+end_src
*** ~pagetitle~
#+begin_src fish
function pagetitle -a URL -d "Gets the title of the webpage linked to the provided URL"
    # -s makes it not print out error message once pipe closes
    curl -Ls "$URL" |
        # max 1 match; after 1 match it closes the pipe
        # .* is in a capture group
        # -r is "replace"; it replaces the match with the first explicit capture group '$1' before printing
        rg -m 1 '<title>(.*)</title>' -r '$1' |
        # trims the whitespace from the matched text
        string trim
end
#+end_src
*** ~templink~
~templink~ creates a symbolic link to the specified directory at ~$TEMP_LINK_NAME~.
This makes it easy to find directories from GUIs.

Let's set ~$TEMP_LINK_NAME~ to ~~/TEMP_LINK~.
#+begin_src fish
set TEMP_LINK_NAME "$HOME/TEMP_LINK"
#+end_src

#+begin_src fish
function templink
    # NOTE can't have quotes around argv, otherwise it will register as single argument
    set length (count $argv)

    # current directory
    if [ $length -eq 0 ]
        set target (realpath .)
    else
        set target (realpath "$argv[1]")
    end

    # https://superuser.com/questions/645842/how-to-overwrite-a-symbolic-link-of-a-directory
    # without the -n flag, it will dereference the symlink first
    # WITH the -n flag, it treats the link as a file and overwrites it normally
    ln -snf "$target" "$TEMP_LINK_NAME"
end
#+end_src

Because I use it so often, it's useful to have an auto-expanding abbreviation for it.
#+begin_src fish
abbr --add tl templink
#+end_src

Let's also make an abbreviation for temp-linking to the parent directory of something.
This is useful in conjunction with our [[id:a740b499-13b5-4988-ab9c-8e47ce9ff69d][Static Shortcuts]], since we can link to the directory containing the filepaths.
#+begin_src fish
abbr --set-cursor=% --add tld 'templink (dirname %)'
#+end_src
*** ~tempdir~
#+begin_src fish
function tempdir -d "Creates a temporary directory at /tmp/$DIRNAME, cd'ing into it if used interactively; if $DIRNAME is multiple words, they are joined with camelCase"
    set DIRNAME (echo "$argv" | sed -r 's/ (.)/\\U\\1/g')
    set DIRNAME "/tmp/$DIRNAME"

    mkdir -p "$DIRNAME" >/dev/null
    echo "$DIRNAME"

    if isatty stdout
        cd "$DIRNAME"
    end
end
#+end_src
*** ~tempclone~
#+begin_src fish
function tempclone -d "Clones git repository into a temporary directory" -a REPO_URL DIRNAME
    if test -z "$REPO_URL"
        echo "Please pass in the url of the repository!" > /dev/stderr
        return 1
    end

    if test -z "$DIRNAME"
        set -f DIRNAME (basename "$REPO_URL")
    end

    set -f FULL_REPO_PATH "/tmp/tempclones/$DIRNAME"
    mkdir -p "$FULL_REPO_PATH"

    git clone "$REPO_URL" "$FULL_REPO_PATH"

    cd "$FULL_REPO_PATH"
end
#+end_src
*** ~media-mode~
~media-mode~ combines ~blackscreen~ with toggling ~safeeyes~.

#+begin_src fish
function media-mode -d "Disables safeeyes while blackscreen is active"
    systemctl --user status safeeyes > /dev/null 2> /dev/null
    set -f was_safeeyes_enabled $status

    set start_time (date +%s)

    if [ $was_safeeyes_enabled -eq 0 ]
        systemctl --user stop safeeyes
    end

    blackscreen

    if [ $was_safeeyes_enabled -eq 0 ]
        systemctl --user start safeeyes
    end

    set end_time (date +%s)

    echo "Closed media-mode after $(format-seconds (math "$end_time - $start_time"))"
end
#+end_src
** Miscellaneous Functions
Because our default shell is ~zsh~... actually nevermind, we'll see
#+begin_src fish :tangle no
function zsh
    set -x NO_EXEC_FISH 1
    /bin/zsh $argv
end
#+end_src
** Miscellaneous Setups
*** =School=
This is a setup for managing different course data and facilitating directory creation/navigation.
**** ~school_set_class~
This is a primitive for changing the currently-set "active class".
It defaults to selecting the current class based on the =Schedule=.
#+begin_src fish
function school_set_class
  # https://stackoverflow.com/questions/56113135/with-sed-or-awk-move-line-matching-pattern-to-bottom-of-file
  set -l AWK_MOVE_MATCH_LAST_LINE "\$0==\"$(school_get_current_class)\"{lastline=\$0;next}{print $0}END{if (lastline != \"\"){print lastline}}"

  # TODO dynamically calculate height
  set -l RESPONSE (fd "" --base-directory $CURRENT_GRADE --max-depth 1 | awk "$AWK_MOVE_MATCH_LAST_LINE" | fzf --height=12 --tac)

  if test "$status" -eq 0
    set -U CLASS_SHORT $RESPONSE
    set -U CLASS_FULL (realpath $CURRENT_GRADE/$CLASS_SHORT)
    # https://unix.stackexchange.com/questions/151999/how-to-change-where-a-symlink-points
    ln -sfn $CLASS_FULL $HOME/Documents/currentClass
  else
    return 1
  end
end
#+end_src
**** ~school_join_zoom~
~school_join_zoom~ will look for the ~./zoom_link~ file in the class directory and attempt to open the URL inside of it.
#+begin_src fish
function school_join_zoom
  if set -q CLASS_FULL
    if not test -e $CLASS_FULL
      echo "Invalid class!"
      return 1
    else
      set -l ZOOM_LINK_PATH "$CLASS_FULL/zoom_link"
      if test -e $ZOOM_LINK_PATH
        echo "Opening zoom link for $CLASS_SHORT"
        spawn firefox (cat $ZOOM_LINK_PATH)
      else
        echo "No zoom link available for $CLASS_SHORT!"
        return 1
      end
    end
  else
    echo "No class set!"
    return 1
  end
end
#+end_src
**** ~school_cd~
#+begin_src fish
function school_cd
  if set -q CLASS_FULL
    if not cd $CLASS_FULL
      echo "Invalid class!"
      return 1
    end
  else
    echo "No class set!"
    return 1
  end
end
#+end_src
**** TODO ~school_goto_subdir~
This is a very involved function for cd'ing (and creating if necessary) subdirectories within class directories, and also date directories.
_I need to refactor this and extract the date directory creation into another function_.
#+begin_src fish
function school_goto_subdir -a BASE_NAME CREATE_DATE_DIR
  function confirm -a PROMPT
    read -lP $PROMPT confirmation

    # TODO condense
    if test "$confirmation" = "y" -o "$confirmation" = "Y";
      return 0
    else
      return 1
    end
  end

  function try_create_dir -a CWD DIRNAME CURRENT_DIRNAME
    # https://stackoverflow.com/questions/31252573/get-current-directory-without-full-path-in-fish-shell
    if not test -d $CWD/$DIRNAME;
      if confirm "Create \"$DIRNAME\" directory in \"$CURRENT_DIRNAME\"? (y/n) ";
        mkdir $CWD/$DIRNAME
      else
        return 1
      end
    end
  end

  # see if CLASS is set
  if set -q CLASS_FULL;
    # if cant cd into it
    if not test -d $CLASS_FULL;
      echo "Invalid class: \"$CLASS_SHORT\""
      return 1
    end

    set -l DIRNAME $CLASS_FULL

    if not try_create_dir $DIRNAME $BASE_NAME $CLASS_SHORT
      return 1
    end

    set -l DIRNAME $DIRNAME/$BASE_NAME

    if test $CREATE_DATE_DIR -eq 1
      set -l DATE_DIR (date "+%m-%d-%y")

      # first, check if there is a date dir with the current date
      set -l DATE_DIRS (fd --max-depth 1 --type directory "$DATE_DIR(_.*)?" "$DIRNAME" | sed -E "s/.*$DATE_DIR(_(.*))?/\\2/")

      set -l EXTRA_INFO ""
      if test -z "$DATE_DIRS"
        set EXTRA_INFO (read -P "Would you like extra info in the dirname [or empty]? " | sed -E 's/\s+/-/g')
      else
        # select from them
        # NOTE: if you quote it, it will become space-separated
        set EXTRA_INFO (string join0 $DATE_DIRS | fzf --height=10 --bind=ctrl-alt-j:print-query --print-query --read0 |
          sed -E 's/\s+/-/g' | sed -E 's:/$::')

        set FZF_STATUS "$pipestatus[2]"

        # NOTE: fzf will print two lines under normal circumstances:
        # 1. the query
        # 2. the selected item
        # if it prints out two lines, that means that we selected something, and so we should set it to the selected item
        if test (count $EXTRA_INFO) -eq 2
          # then, pick the second one
          set EXTRA_INFO $EXTRA_INFO[2]
        end

        # if fzf errored out
        if test "$FZF_STATUS" -eq 2
          # ctrl-c or escape status
          or test "$FZF_STATUS" -eq 130
          return 1
        end
      end

      set -l SUBDIR_NAME ""
      if test -z "$EXTRA_INFO";
        set SUBDIR_NAME "$DATE_DIR"
      else
        set SUBDIR_NAME "$DATE_DIR""_$EXTRA_INFO"
      end

      if not try_create_dir $DIRNAME $SUBDIR_NAME $CLASS_SHORT/$BASE_NAME;
        # return 1
        cd $DIRNAME
      else
        cd "$DIRNAME/$SUBDIR_NAME"
      end
    else
      cd $DIRNAME
    end
  else;
    echo "Current class not set!"
    return 1
  end
end
#+end_src
**** ~school_fzf_filter_cd_subdirectory~
This function is the user-facing side of ~school_goto_subdir~.
It offers an ~fzf~ menu for ~cd~'ing to a predefined list of subdirectories, as well as the directories already in the school directory.
It will also create directories that do not already exist.
#+begin_src fish
function school_fzf_filter_cd_subdirectory -a CREATE_DATE_DIR
  # list only directories
  # set -l directories (fd -td -d1 $CLASS_FULL)
  # https://stackoverflow.com/questions/8518750/to-show-only-file-name-without-the-entire-directory-path
  set -l directories (find $CLASS_FULL -maxdepth 1 ! -path $CLASS_FULL -type d | xargs -n 1 basename)

  for i in "homework" "classwork" "tests" "notes"
    if not test -d $CLASS_FULL/$i
      set -a directories "* $i"
    end
  end

  # only look at the last line
  set -l target (string join \n $directories | fzf --height=10 --print-query | tail -n 1)
  # echo "Target is $target"

  # string is empty
  # means that the user hit escape to exit
  if test -z "$target"
    return 1
  else
    # if it starts with a *, get rid of it
    set -l target_processed (string match -r "\* (.*)" "$target" | tail -n 1)

    if test -z "$target_processed"
      school_goto_subdir "$target" "$CREATE_DATE_DIR"
    else
      school_goto_subdir "$target_processed" "$CREATE_DATE_DIR"
    end
  end
end
#+end_src
**** ~school_open_notes~
#+begin_src fish
function school_open_notes
  e $CLASS_FULL/notes/(string lower $CLASS_SHORT)_notes.org
end
#+end_src
**** Schedule Processing
The following functions process the schedule.

This is a helper function for converting 24H time to minutes.
#+begin_src fish
function __school_time_to_minutes -a TIME
  set -l SPLIT_TIME (string split ':' $TIME)
  math "$SPLIT_TIME[1] * 60 + $SPLIT_TIME[2]"
end
#+end_src

***** ~__school_compute_schedules~
This function goes through all of the ~.schedule~ files within each course directory and assembles a chronological order of courses for each day.
It stores these day-by-day schedules in ~$COURSE_SCHEDULE_<Day>~.

*NOTE*: This function must be called manually anytime the schedules are changed.
#+begin_src fish
function __school_compute_schedules
  # first, clear existing schedules
  set -l DAY_NAMES Monday Tuesday Wednesday Thursday Friday
  for day_name in $DAY_NAMES
    set -e "COURSE_SCHEDULE_"$day_name
  end

  # iterate through all current classes and see if there's a schedule
  #
  # https://stackoverflow.com/questions/13525004/how-to-exclude-this-current-dot-folder-from-find-type-d.
  # by default, when searching with the type `d`, the current directory (.) is included. to get rid of it, we add `mindepth 1`.
  # `-type l -xtype d` filters for symlinks to directories.
  # `-a` is an AND combinator.
  # `-o` is an OR combinator.
  # like in every language, (I assume) that `and` has lower precedence than `or`, meaning that this expression is equivalent to (a & (b | c))
  for course in (find "$CURRENT_GRADE" -mindepth 1 -a -type l -xtype d -o -type d)
    set -l COURSE_NAME (path basename "$course")
    set -l SCHEDULE_PATH "$CURRENT_GRADE/$COURSE_NAME/.schedule"

    # now, let's load the current schedule file, if it exists
    if test -n "$SCHEDULE_PATH"
      for line in (cat "$SCHEDULE_PATH" | string split '\n');
        set -l WORDS (string split ' ' "$line")
        set -l DAYS (string split ',' "$WORDS[1]")
        set -l TIME (string split '-' "$WORDS[2]")

        set -l PROCESSED_TIME (__school_time_to_minutes "$TIME[1]") (__school_time_to_minutes "$TIME[2]")

        for day in $DAYS
          set -l DAY_VARNAME "COURSE_SCHEDULE_""$day"

          set -fa "$DAY_VARNAME" "$PROCESSED_TIME $COURSE_NAME"
        end
      end
    end
  end

  # now, let's sort each schedule
  for day_name in $DAY_NAMES
    set -l DAY_VARNAME "COURSE_SCHEDULE_""$day_name"

    set -U $DAY_VARNAME (sort -n (string join \n $$DAY_VARNAME[1] | psub) | string split ' ')
  end
end
#+end_src

***** ~school_get_current_class~
This function gets the current class based on the time and day.
#+begin_src fish
function school_get_current_class -a CURRENT_TIME -a CURRENT_DAY
  if test -z "$CURRENT_TIME"
    # %R: 24-hour hour and minute
    set -f CURRENT_TIME (__school_time_to_minutes (date "+%R"))
  end

  if test -z "$CURRENT_DAY"
    set -f CURRENT_DAY (date "+%A")
  end

  set -l DAY_VARNAME "COURSE_SCHEDULE_""$CURRENT_DAY"

  if test -z "$$DAY_VARNAME"
    # no class today
    return 1
  end

  set -l DAY_LIST $$DAY_VARNAME
  # how many minutes after the end of class are you still in the class for?
  set -l MINUTES_LEEWAY 1
  # now, iterate through the courses in the day until we find one that matches
  for index in (seq 1 3 (math "$(count $DAY_LIST)" - 1))
    set -l TIME_RANGE "$DAY_LIST[$index]" "$DAY_LIST[$(math $index + 1)]"

    # don't check the start time at all so that we can go to class early
    if test $CURRENT_TIME -le (math "$TIME_RANGE[2] + $MINUTES_LEEWAY")
      echo "$DAY_LIST[$(math $index + 2)]"
      return 0
    end
  end

  return 1
end
#+end_src

***** ~school_get_previous_class~
This function gets the previous class based on the time and day.
#+begin_src fish
function school_get_previous_class -a CURRENT_TIME -a CURRENT_DAY
  if test -z "$CURRENT_TIME"
    # %R: 24-hour hour and minute
    set -f CURRENT_TIME (__school_time_to_minutes (date "+%R"))
  end

  if test -z "$CURRENT_DAY"
    set -f CURRENT_DAY (date "+%A")
  end

  set -l DAY_VARNAME "COURSE_SCHEDULE_""$CURRENT_DAY"

  if test -z "$$DAY_VARNAME"
    # no class today
    return 1
  end

  set -l DAY_LIST $$DAY_VARNAME
  # how many minutes after the end of class are you still in the class for?
  set -l MINUTES_LEEWAY 1
  # now, iterate through the courses in the day until we find one that matches
  for index in (seq 1 3 (math "$(count $DAY_LIST)" - 1))
    set -l TIME_RANGE "$DAY_LIST[$index]" "$DAY_LIST[$(math $index + 1)]"

    # don't check the start time at all so that we can go to class early
    if test $CURRENT_TIME -le (math "$TIME_RANGE[2] + $MINUTES_LEEWAY")
      set -l PREVIOUS_CLASS_INDEX (math $index - 1)

      if test "$PREVIOUS_CLASS_INDEX" -lt 1
        # set it to the first class
        set PREVIOUS_CLASS_INDEX 3
      end

      echo "$DAY_LIST[$PREVIOUS_CLASS_INDEX]"
      return 0
    end
  end

  return 1
end
#+end_src
**** Aliases
#+begin_src fish
# change current class
alias _sc="school_set_class"

# go to current class
alias scd="school_cd"

# change current class and go to current class
alias _scd="school_set_class && school_cd"

# go to current class's notes/homework/classwork/tests directory
alias scf="school_fzf_filter_cd_subdirectory 0"

# change current class and go to current class's notes/homework/classwork/tests directory
alias _scf="school_set_class && scf"

# go to current class's notes/homework/classwork/tests directory, make current date directory
alias scfd="school_fzf_filter_cd_subdirectory 1"

# change current class and go to current class's notes/homework/classwork/tests directory, make current date directory
alias _scfd="school_set_class && scfd"

# join current class's zoom link
# CLASS_DIR/zoom_link
alias sjz="school_join_zoom"

# change current class and join current class's zoom link
# CLASS_DIR/zoom_link
alias _sjz="school_set_class && school_join_zoom"

# NOTE: added `p` to the end because `scp` is already a program
alias scpr='echo Current class is \"$CLASS_SHORT\"'

# open notes for current class
alias scn="school_open_notes"

# change current class and open notes for current class
alias _scn="school_set_class && school_open_notes"
#+end_src
*** =Shell uptime=
Let's set the start time as a variable, so we can see how long our shell has been running.
Note that we tangle this to ~config.fish~ so it gets sourced immediately.
#+begin_src fish :tangle ./config.fish
if not set -q SHELL_START_TIME
    set -g SHELL_START_TIME (date +%s)
end
#+end_src

This is an alias which pretty-prints our start time variable.
#+begin_src fish
alias shell_start_time='date -d @$SHELL_START_TIME +"%m-%d-%y %r"'
#+end_src

This function computes the time elapsed since the shell was launched.
#+begin_src fish
function shell_uptime
  set -l CURRENT_TIME (date +%s)
  set -l TIME_ELAPSED (math "$CURRENT_TIME - $SHELL_START_TIME")

  format-seconds "$TIME_ELAPSED"
end
#+end_src
*** =Scripts=
This is a setup for easily storing one-off scripts.

**** ~newscript~
First, ~newscript~ creates a new script with a random name based on the parameters.
#+begin_src fish
function newscript
  # newscript filename extension
  # newscript extension

  set random_characters (cat /dev/urandom | tr -cd '[:alnum:]' | head -c 16)

  if not test -z "$argv[2]"
    set filename "$argv[1]-$random_characters"
    set extension "$argv[2]"
  else
    set filename "$random_characters"
    set extension "$argv[1]"
  end

  set full_filename "$filename.$extension"

  v "$SCRIPTS_PATH/$full_filename"

  chmod +x "$SCRIPTS_PATH/$full_filename"
end
#+end_src

**** ~get_last_script~
~get_last_script~ yields the filename of the latest created script.
#+begin_src fish
function get_last_script
  set file (ls -t "$SCRIPTS_PATH" | head -n1)

  if not test -z "$file"
    set file "$SCRIPTS_PATH/$file"
  end

  echo "$file"
end
#+end_src

**** ~scripts~
~scripts~ uses ~fzf~ to filter through the scripts, opening the selected one in ~nvim~.
#+begin_src fish
function scripts
  set file (ls -t "$SCRIPTS_PATH" | fzf --preview 'bat --color "always" $SCRIPTS_PATH/{}' --preview-window=right:80%)

  if test "$status" -eq 0
    v "$SCRIPTS_PATH/$file"
  end
end
#+end_src

**** ~editlastscript~ | ~runlastscript~
The following functions are shortcuts for editing/running the latest created script.
#+begin_src fish
function editlastscript
  v (get_last_script)
end
#+end_src

#+begin_src fish
function runlastscript -a executable
  set scriptName (get_last_script)

  if test -z "$scriptName"
    echo "No scripts found!"
  else
    if test -z "$executable"
      $scriptName "$argv[2..-1]"
    else
      $executable $scriptName "$argv[2..-1]"
    end
  end
end
#+end_src
*** =Notes=
This setup is intended to keep track of all the different notes files I have on my system.
The problem it's trying to solve is: I take notes on all of my projects individually, but I don't know where to find them afterwards.
This has now been made obsolete because I started using Org Mode for everything, and keep all of my notes in ~~/notes/_~.
#+begin_src fish
set NOTES_REGISTRY_NAME ".notes_registry.csv"
set MASTER_NOTES_REGISTRY "$HOME/notes/$NOTES_REGISTRY_NAME"
#+end_src

#+begin_src fish
function registernotes -a NOTES_PATH
  # see if its already registered
  set NOTES_PATH (realpath "$NOTES_PATH")

  # see if there is a registry in the current directory
  if [ -e "./$NOTES_REGISTRY_NAME" ]
    set -l NOTES_REGISTRY "./$NOTES_REGISTRY_NAME"
  else
    # ask user if they want to create a registry in the current directory
    set -l NOTES_REGISTRY "$MASTER_NOTES_REGISTRY"
  end

  # quiet, max 1 match
  if rg -qm1 "$NOTES_PATH\$" "$NOTES_REGISTRY"
    # already registered
    echo "Already registered!" > /dev/stderr
    return 1
  end

  # otherwise, open file with vim or xdg-open
  # https://stackoverflow.com/a/53233847
  if [ (basename "$NOTES_PATH") = "$NOTES_REGISTRY_NAME" ]
    set EXTENSION 'registry'
  else
    set EXTENSION (string split -m1 -r '.' "$NOTES_PATH")[2]
  end

  echo "$argv[2..] {$EXTENSION}|$NOTES_PATH" >> "$MASTER_NOTES_REGISTRY"
end
#+end_src

#+begin_src fish
function searchnotes -a NOTES_REGISTRY -a FZF_HEADER
  # set notes registry to master if none provided
  # https://stackoverflow.com/questions/54524521/in-fish-shell-how-to-set-a-variable-with-default-fallback
  test -z "$NOTES_REGISTRY"; and set "$NOTES_REGISTRY" "$MASTER_NOTES_REGISTRY"

  set -l SELECTION (cat "$NOTES_REGISTRY" | fzf --nth 1 -d "|" --height=20)

  if [ "$status" -neq 0 ]
    # non-zero exit code
    return 1
  end

  set -l PATH (echo "$SELECTION" | cut -d "|" -f "2")

  # if selection is a registry (.notes_registry), recurse
  if [ basename "$SELECTION" = "$NOTES_REGISTRY_NAME" ]
    set -l DESCRIPTION (echo "$SELECTION" | cut -d "|" -f "1")
    searchnotes "$SELECTION" "$DESCRIPTION"
  else
    # otherwise, open file with vim or xdg-open
    # https://stackoverflow.com/a/53233847
    set -l EXTENSION (string split -m1 -r '.' "$PATH")[2]

    switch $EXTENSION
      case md txt
        v "$PATH"
      case '*'
        xdg-open "$PATH"
    end
  end
end
#+end_src
*** =localvrc=
#+begin_src fish
function normalize_path -a VRC_PATH
  if test -d "$VRC_PATH"
    realpath "$VRC_PATH"
  else
    realpath "$VRC_PATH" | xargs -n1 dirname
  end
end
#+end_src

#+begin_src fish
function check_path_exists -a VRC_PATH
  if test -e "$LOCAL_VIMRC_PATHS"
    rg -Fx "$VRC_PATH" "$LOCAL_VIMRC_PATHS" > /dev/null
  else
    return 1
  end
end
#+end_src
*** =exercism= wrapper
Here, we override the ~download~ subcommand for the ~exercism~ CLI.
I believe it's because (this was a while ago) ~exercism~ downloads everything into a static path, but I like choosing where my files go.
This version of ~exercism~ allows you to download challenges to the current directory.
#+begin_src fish
set EXERCISM_BINARY_PATH "/usr/bin/exercism"

# wrap the exercism CLI with custom 'download' behavior
function exercism --wraps $EXERCISM_BINARY_PATH
  if [ $argv[1] = "download" ]
    # save output to variable
    set -l DOWNLOAD_PATH ($EXERCISM_BINARY_PATH $argv 2> /dev/null)

    # if success
    if [ $status -eq 0 ]
      # move
      mv $DOWNLOAD_PATH .

      set -l CHALLENGE_NAME (basename (realpath $DOWNLOAD_PATH))
      set -l TRACK_PATH (dirname (realpath $DOWNLOAD_PATH))

      rmdir $TRACK_PATH

      echo "Downloaded to $CHALLENGE_NAME"
    else
      echo $OUTPUT
      return $status
    end
  else
    $EXERCISM_BINARY_PATH $argv
  end
end
#+end_src
*** =Encryption=
This setup consists of a series of functions for editing/viewing encrypted files.
**** ~encstream~
This streams encrypted videos into ~vlc~.
#+begin_src fish
function encstream -a FILE
  gpg -qd --no-symkey-cache "$FILE" | vlc -
end
#+end_src
**** ~encpager~
This function pages encrypted files using ~less~.
#+begin_src fish
function encpager -a FILE
  gpg -qd --no-symkey-cache "$FILE" | less
end
#+end_src
**** ~_encvi_fish_impl~
This is a rudimentary and insecure version of my ~encvi~ program for editing encrypted files.
The issue with this version is that it uses ~vipe~, which works by writing files to ~/tmp~, where they are globally visible.
#+begin_src fish
function _encvi_fish_impl -a FILE
  # https://github.com/dideler/fish-read-silent/blob/master/read_silent.fish
  # https://github.com/fish-shell/fish-shell/issues/838#issuecomment-118206906
  stty -echo
  head -n 1 | read -slP "Password: " password > /dev/null
  stty echo

  # incognito mode
  set -lx EDITOR "nvim -i NONE"

  # https://github.com/fish-shell/fish-shell/issues/1147
  # don't split contents on spaces/newlines
  set -lx IFS ''
  set -l --long TEXT (if test -e "$FILE"; gpg -qd --no-symkey-cache --batch --passphrase "$password" "$FILE" 2> /dev/null; else; echo ""; end)

  if test $status -ne 0
    echo "Incorrect password!"
    return 1
  else
    echo  "$TEXT" |
    vipe |
    gpg -qc --yes --no-symkey-cache --batch --passphrase "$password" --output "$FILE"
  end
end
#+end_src
*** =at-improved=
To allow for lazy loading of the ~at~ daemon, I added a sudoers entry which allows
my user to start the ~atd~ service with ~sudo systemctl start atd~ without specifying
a root password.
**** ~do-in~
~do-in~ runs a command in a certain amount of time.
Usage: ~do-in 5m "echo hello world"~
#+begin_src fish
function do-in
  set matches (string match -r "(\d+)(\w+)" "$argv[1]")

  switch $matches[3]
    case "m*"
      set b "minutes"
    case 'h*'
      set b 'hour'
    case '*'
      exit 1
  end

  sudo systemctl start atd
  echo "$argv[2] \"$argv[3]\" \"$argv[4]\"" | at "now + $matches[2]$b"
end
#+end_src
**** ~remindin~
This is a specialization of ~do-in~ which uses ~notify-send~ to display a notification after a certain amount of time.
#+begin_src fish
function remindin
  sudo systemctl start atd
  do-in "$argv[1]" "notify-send -u critical" "$argv[2]" "$argv[3..-1]"
end
#+end_src
**** ~remindat~
This function is like ~remindin~, except it takes in an absolute time rather than a relative time.
#+begin_src fish
function remindat
  sudo systemctl start atd
  echo "notify-send -u critical \"$argv[2]\" \"$argv[3..-1]\"" | at "$argv[1]"
end
#+end_src
*** =zfs Snapshot Cloning=
This setup allows you to easily interact with old versions of files and directories.
**** ~zfs-get-snapshot-path~
:PROPERTIES:
:header-args:perl: :tangle ~/.config/fish/utils/zfs-snapshot-cloning/get-containing-volume.pl
:END:

In order to determine which ZFS volume contains a given path, we will use a Perl script.
#+begin_src perl
use strict;
use warnings;

use Cwd 'realpath';
use File::Basename qw(dirname basename);

# first, let's get the given path
my $targetPath = realpath($ARGV[0]);
my $usingParentDir = 0;
my $fileComponent = undef;

FINDMNT:

my ($targetMountPoint, $sourceMountPoint, $fsType) = split " ", `findmnt --output target,source,fstype --noheadings --target $targetPath`;
my $exitCode = $?;
if ($exitCode != 0 || $fsType ne "zfs") {
    if (!($usingParentDir eq 1)) {
        $usingParentDir = 1;
        $fileComponent = basename($targetPath);
        $targetPath = dirname($targetPath);

        goto FINDMNT;
    }

    print STDERR "Path is not under a ZFS volume.\n";
    exit 1;
}

# now, let's cut out the target mountpoint from the path so we're left with the relative path
if (!($targetPath =~ s/$targetMountPoint//)) {
    print "Invalid target and source mountpoints!\n";
    exit 1;
}

# print out the volume path
print "$sourceMountPoint\n";

if (defined $fileComponent) {
    # print out the path relative to the volume
    print "${targetPath}/${fileComponent}\n";
} else {
    # print out the path relative to the volume
    print "$targetPath\n";
}
#+end_src

Let's make it possible to interface directly with our backup server, to get snapshots which aren't available locally.
#+begin_src fish
set -gx ZFS_REMOTE_BACKUP_MOUNTPOINT /tmp/kalavara-remote
#+end_src

This function will get the path of a given file or directory under a selected snapshot.
#+begin_src fish
function zfs-get-snapshot-path
    argparse -N 1 -X 1 'h/help' 'r/remote' -- $argv
    set TARGET_PATH $argv[1]

    set PERL_SCRIPT_PATH ~/.config/fish/utils/zfs-snapshot-cloning/get-containing-volume.pl

    set output (perl $PERL_SCRIPT_PATH $TARGET_PATH | string split "\n")
    set script_status $pipestatus[1]

    if test $script_status -ne 0
        return $script_status
    end

    set mountpoint /$output[1]
    set relative_path $output[2]

    if set -q _flag_remote
        set root_remote_path (zfs get -Ho value "kalavara:root-remote-path" "$mountpoint")
        set dataset_remote_path (zfs get -Ho value "kalavara:remote-path" "$mountpoint")

        if not test -e "$ZFS_REMOTE_BACKUP_MOUNTPOINT"
            # we use --mountpoint instead of --target to only match exact path
            or not findmnt --mountpoint "$ZFS_REMOTE_BACKUP_MOUNTPOINT" > /dev/null
            mkdir -p "$ZFS_REMOTE_BACKUP_MOUNTPOINT"

            # then, let's mount it read-only
            # https://stackoverflow.com/questions/35830509/sshfs-linux-how-to-mount-with-read-only-access
            sshfs kalavara_external:"$root_remote_path/.mounts" "$ZFS_REMOTE_BACKUP_MOUNTPOINT" -o ro || return 1
        end

        set mountpoint "$ZFS_REMOTE_BACKUP_MOUNTPOINT/$dataset_remote_path"

        # if remote, then let's list all of the bookmarks.
        # the consecutive cuts are necessary since cut can't take in a full string as a delimeter
        set chosen_snapshot (zfs list -t bookmark $output[1] -H -o name | fzf | cut -d '#' -f 2 | cut -d '_' -f 2-)
    else
        # now, pick a snapshot
        set chosen_snapshot (zfs list -t snapshot $output[1] -H -o name | fzf | cut -d '@' -f 2)
    end

    # now, yield
    echo "$mountpoint/.zfs/snapshot/$chosen_snapshot$relative_path"
end
#+end_src

Let's make an alias and abbreviation to make it easier to use.
#+begin_src fish
alias snapshot-path=zfs-get-snapshot-path
abbr --add sp snapshot-path
#+end_src
**** ~zfs-remote-disconnect~
Let's make a function to disconnect from the remote after we no longer need it.
#+begin_src fish
function zfs-remote-disconnect -d "Disconnects the SSHFS mount for the remote backup server."
    umount "$ZFS_REMOTE_BACKUP_MOUNTPOINT"
end
#+end_src
*** =Temporary Backups=
This is a setup for easily backing up and restoring files or folders by saving them to ~/tmp~.
#+begin_src fish
set -gx "TEMP_BACKUP_DIRECTORY" "/tmp/temp-backups"
#+end_src

**** ~__compute-temp-backup-path~
Let's write a helper function for computing the backup path for a given path.
#+begin_src fish
function __compute-temp-backup-path -a TARGET_PATH
    set encoded_path (string escape --style=url "$(realpath "$TARGET_PATH")" | sed 's:/:%:g')

    echo "$TEMP_BACKUP_DIRECTORY/$encoded_path"
end
#+end_src
**** ~temp-backup~
First, we'll write the function for backing up the paths.
#+begin_src fish
function temp-backup -d "Backs up the specified file/folder to a temporary location" -a TARGET_PATH
    if [ -z "$TARGET_PATH" ]
        echo "Defaulting to '.'"
        set TARGET_PATH "."
    end

    set backup_path (__compute-temp-backup-path "$TARGET_PATH")

    mkdir -p (dirname "$backup_path")

    # signal that's it's a directory if it's a directory;
    # this helps with `rsync`, preventing it from copying the raw directory and
    # instead copying the contents
    if [ -d "$TARGET_PATH" ]
        set TARGET_PATH "$TARGET_PATH/"
    end

    # effectively copies anything over to the backup path that's changed
    rsync -ra --delete --delete-delay "$TARGET_PATH" "$backup_path"
end
#+end_src

Let's add an abbreviation to make it easier to type.
#+begin_src fish
abbr --add tb 'temp-backup'
#+end_src
**** ~temp-restore~
Next, we'll write the function for restoring them.
#+begin_src fish
function temp-restore -d "Restores the specified file/folder from a temporary location"
    argparse 'h/help' 'd/delete-stale' 'q/quiet' -- $argv
    or return 1

    set TARGET_PATH $argv[1]
    if [ -z "$TARGET_PATH" ]
        echo "Defaulting to '.'"
        set TARGET_PATH "."
    end

    # default to update only;
    # NOTE: argparse normalizes dash characters to underscores
    if not set -q _flag_delete_stale
        # then, update only
        set mode "update-only"
    else
        set mode "delete-stale"
    end

    set realpath_target (realpath "$TARGET_PATH")
    set backup_path (__compute-temp-backup-path "$TARGET_PATH")

    if [ -e "$backup_path" ]
        # delete what we're about to restore
        if [ "$mode" = "delete-stale" ]
            # https://superuser.com/questions/1425614/rsync-delete-folders-from-destination-if-does-not-exists-in-source.
            # `delete` signals to delete anything on the receiving end not present in the source.
            # `--delete-delay` says to compute the list of files to delete during the copy, and then delete them afterwards.
            set extra_rsync_args "--delete" "--delete-delay"
        else
            set extra_rsync_args
        end

        if not set -q _flag-quiet
            set --append extra_rsync_args -v
        end

        if [ -d "$backup_path" ]
            set backup_path "$backup_path/"
        end

        rsync -ra $extra_rsync_args "$backup_path" "$realpath_target"
    else
        echo "No backup exists!" > /dev/stderr
        return 1
    end
end
#+end_src
* Environment Variables
:PROPERTIES:
:header-args:fish: :tangle ./env.fish
:END:

#+begin_src fish
set YARN_BIN "$HOME/.yarn/bin"
set MANPATH /usr/share/man ~/.local/share/man/

set -gx GEM_HOME ~/.gem

set CUSTOM_PATHS ~/bin ~/.emacs.d/bin ~/.ghcup/bin ~/.npm/bin ~/.cargo/bin ~/.local/bin ~/go/bin ~/Packages/language-servers/Binaries $YARN_BIN ~/.gem/ruby/3.0.0/bin

set -x DOCKER_HOST "unix:///run/user/1000/docker.sock"
set -x DOCKER_BIN ~/.local/bin

if set -q _OLD_VIRTUAL_PATH
  set PATH $VIRTUAL_ENV/bin $_OLD_VIRTUAL_PATH
else
  for path in $CUSTOM_PATHS
      fish_add_path -gp $path
  end
end

set -gx VISUAL nvim
set -gx EDITOR "$VISUAL"

# https://medium.com/@sidneyliebrand/how-fzf-and-ripgrep-improved-my-workflow-61c7ca212861
set -gx FZF_DEFAULT_COMMAND 'fd --type file --no-ignore-vcs --hidden'
set -gx FZF_CTRL_T_COMMAND 'fd --type file --no-ignore-vcs --hidden'
set GOPATH "$HOME/go"
set JAVA_HOME /usr/lib/jvm/java-8-openjdk/
set -gx BD_OPT 'insensitive'


set -gx STACK_ROOT "$HOME/.config/stack"

set -gx CURRENT_GRADE "$HOME/Documents/school/college2/spring-classes"
set -gx SCRIPTS_PATH "$HOME/Development/Scripts/single-use"

# this is needed for Unity to work properly on my system
set -gx FrameworkPathOverride /lib/mono/4.5
#+end_src
* Plugin Configuration
:PROPERTIES:
:header-args:fish: :tangle ./plugin_config.fish
:END:
* Buffer Setup
** Compute Tangle File
#+NAME: compute-tangle-file
#+begin_src emacs-lisp :results none
(defun srithon/compute-fish-config-tangle-file ()
  ;; if the block contains an alias, put it in the `functions.fish` file
  ;; if the block does not contain any aliases, put it in a file corresponding to the heading title
  (let* ((src-block (org-element-at-point-no-context))
         (src-body (org-element-property :value src-block))
         (contains-alias (string-match-p (rx (seq line-start (or "alias" "abbr"))) src-body)))
    (if contains-alias
        "impure-aliases.fish"
      (let ((core-name (or
                        (org-element-property :name src-block)
                        (org-entry-get (point) "function-name" t)
                        ;; next, parse the code block contents and find the name of the function
                        (when
                            (string-match
                             (rx (seq
                                  line-start
                                  "function"
                                  (+ whitespace)
                                  (group (+ (not whitespace)))))
                             src-body)
                          ;; note that when `string-match` is called
                          ;; with a string parameter, you must call
                          ;; `match-string` with that same string
                          (match-string 1 src-body))
                        ;; no function, no alias, there must be a `set`
                        (when
                            (string-match
                             (rx (seq line-start "set" whitespace))
                             src-body)
                          'env)
                        (when-let ((heading-title (org-get-heading t t t t)))
                          (replace-regexp-in-string
                           (rx (+ whitespace)) "-"
                           (downcase
                            (replace-regexp-in-string (rx "~") "" heading-title)))))))
        (if (eq core-name 'env)
            "./env.fish"
          (format "functions/%s.fish" core-name))))))
#+end_src
** Local Variables
Local Variables:
Eval: (org-sbe "compute-tangle-file")
End:
